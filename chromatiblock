#!/usr/bin/env python3

        # chromatiblock - Scalable, whole-genome visualisation of structural changes in prokaryotes
        # Copyright (C) 2019 Mitchell J Sullivan
        #
        # This program is free software: you can redistribute it and/or modify
        # it under the terms of the GNU General Public License as published by
        # the Free Software Foundation, either version 3 of the License, or
        # (at your option) any later version.
        #
        # This program is distributed in the hope that it will be useful,
        # but WITHOUT ANY WARRANTY; without even the implied warranty of
        # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        # GNU General Public License for more details.
        #
        # You should have received a copy of the GNU General Public License
        # along with this program.  If not, see <https://www.gnu.org/licenses/>.




import os
import subprocess
import sys
import argparse



# if given a tuple of RGB values (0-255) retrun a hex string
def colorstr(rgb): return "#%02x%02x%02x" % (rgb[0],rgb[1],rgb[2])


color_list = [(240,163,255), (0,117,220), (153,63,0), (76,0,92), (25,25,25), (0,92,49), (43,206,72), (255,204,153),
              (128,128,128), (148,255,181), (143,124,0), (157,204,0), (194,0,136), (0,51,128), (255,164,5), (255,168,187),
              (66,102,0), (255,0,16), (94,241,242), (0,153,143), (224,255,102), (116,10,255), (153,0,0), (255,255,0), (255,80,5)]

pattern_list = ['horizontal', 'forward_diag', 'reverse_diag']



# class for creating SVGs (or a webpage with an embedded SVG)
class scalableVectorGraphicsHTML:
    # if svg output is selected will create a raw svg file. Otherwise will embed the svg in a simple HTML document
    def __init__(self, height, width, svg=True, pan_zoom_location='http://ariutta.github.io/svg-pan-zoom/dist/svg-pan-zoom.min.js', texta="chromatiblock Figure"):
        self.height = height
        self.width = width
        heightmm = int(210 * height / width)
        if svg:
            self.out = '      <svg id="demo-tiger" xmlns="http://www.w3.org/2000/svg" width="210mm" height="%dmm"' % heightmm + \
'                   viewBox="0 0 %d %d" version="1.1">\n' % (width, height) + '<g>\n'
        else:
            self.out = '<!DOCTYPE html>\n' + \
    '<html>\n' + \
    '  <head>\n' + \
    '    <script src="' + pan_zoom_location + '"></script>\n' + \
    '<style> body {\n' + \
    '    color: #2F2F2F;\n' + \
    '    font-size: small;\n' + \
    '    font-family: arial, verdana, tahoma, sans-serif;\n' + \
    '}\n' + \
    'h1 {\n' + \
    '    size: 130%;\n' + \
    '    border-bottom: 1px solid #888;\n' + \
    '}\n' + \
    'h2 {\n' + \
    '    size: 120%;\n' + \
    '    border-bottom: 1px solid #888;\n' + \
    '}\n' + \
    'h3 {\n' + \
    '    size: 110%;\n' + \
    '}\n' + \
    'h4 {\n' + \
    '    size: 107%;\n' + \
    '    border-bottom: 1px solid #888;\n' + \
    '}\n' + \
    'h5 {\n' + \
    '    size: 105%;\n' + \
    '}\n' + \
    'h6 {\n' + \
    '    size: 102%;\n' + \
    '}\n' + \
    'a {\n' + \
    '    color: #39F;\n' + \
    '    text-decoration: none;\n' + \
    '}\n' + \
    'a:hover {\n' + \
    '    color: #00F;\n' + \
    '    text-decoration: underline;\n' + \
    '}</style>\n' + \
    '  </head>\n' + \
    '  <body>\n' + \
    '    <h1>' + texta + '</h1>\n' + \
    '    <div id="container" style="width: 100%; height: 800px; border:0px solid black; ">\n' + \
    '      <svg id="demo-tiger" xmlns="http://www.w3.org/2000/svg" style="display: inline; width: inherit; min-width: inherit;' + \
    '                   max-width: inherit; height: inherit; min-height: inherit; max-height: inherit; " viewBox="0 0 %d %d" version="1.1">\n' % (width, height) + \
    '    <style>\n' + \
    '      #all:hover .bar {\n' + \
    '        opacity:0.1;\n' + \
    '                       }\n' + \
    '      #all:hover .bar:hover {\n' + \
    '        opacity: 1.0;\n' + \
    '        stroke-width:80;\n' + \
    '                       }\n' + \
    '    </style>\n' + \
    '<g id="all">\n'

    # draw a Line
    def drawLine(self, x1, y1, x2, y2, th=1, cl=(0, 0, 0)):
        self.out += '  <line x1="%d" y1="%d" x2="%d" y2="%d"\n        stroke-width="%d" stroke="%s" />\n' % (x1, y1, x2, y2, th, colorstr(cl))


    # end the svg for the main figure and then add the html for the legend. Create the svg for the header of the legend.
    def seperate_figure(self, width, height):
        self.out += '''</g>      </svg>
    </div>
    <button id="enable">enable zoom</button>
    <button id="disable">disable zoom</button>
    <button id="hide">hide genes</button>
    <button id="show">show genes</button>
    <h2>Legend</h2>
    <script>
      // Don't use window.onLoad like this in production, because it can only listen to one function.
      window.onload = function() {
        // Expose to window namespase for testing purposes
        window.zoomTiger = svgPanZoom('#demo-tiger', {
          zoomEnabled: true,
          controlIconsEnabled: true,
          fit: true,
          center: true,
          maxZoom: 1000,
          zoomScaleSensitivity: 0.5
        });

        document.getElementById('enable').addEventListener('click', function() {
          window.zoomTiger.enableControlIcons();
        })
        document.getElementById('disable').addEventListener('click', function() {
          window.zoomTiger.disableControlIcons();
        })
        document.getElementById('hide').addEventListener('click', function() {
          document.getElementById("annot").style.display = "none";
        })
        document.getElementById('show').addEventListener('click', function() {
          document.getElementById("annot").style.display = "block";
        })
      };
    </script>
    '''
        self.out += '<div id="container" style="width: 100%; height: auto; border:0px solid black; ">\n'
        self.out += ' <svg id="legend" xmlns="http://www.w3.org/2000/svg" style="display: inline; width: inherit; min-width: inherit;' + \
'                   max-width: inherit; height: inherit; min-height: inherit; max-height: inherit; " viewBox="0 0 %d %d" version="1.1">\n<g>' % (width, height)

    # write the svg to a file
    def writesvg(self, filename, svg=True, textb=''):
        with open(filename, 'w') as outfile:
            outfile.write(self.out)
            if svg:
                outfile.write('</g></svg>')
            else:
                outfile.write('</div></g>      </svg>\n<p> ')
                outfile.write(textb)
                outfile.write('</p>\n  </body>\n</html>')

    # Draw a rectangle with a slowly transitioning fill
    def drawHueGradient(self, x1, y1, wid, hei, s, l, hmin=0, hmax=360):
        self.out += '  <defs>\n    <linearGradient id="HueGradient" x1="0%" y1="0%" x2="100%" y2="0%">\n'
        iterations = 20
        for i in range(iterations):
            color = hsl_to_rgb(hmin+(hmax-hmin)/iterations * i, s, l)
            colorstring = colorstr(color)
            self.out += '      <stop offset="%d%%" stop-color="%s" />\n' % (100/iterations * i, colorstring)
            color = hsl_to_rgb(hmin+(hmax-hmin)/iterations * (i+1), s, l)
            colorstring = colorstr(color)
            self.out += '      <stop offset="%d%%" stop-color="%s" />\n' % (100/iterations * (i + 1), colorstring)
        self.out += '    </linearGradient>\n</defs>\n'
        self.out += '  <rect fill="url(#HueGradient)" stroke-width="1"\n'
        self.out += '        x="%d" y="%d" width="%d" height="%d" />\n' % (x1, y1, wid, hei)

    # draw a outline rectangle
    def drawOutRect(self, x1, y1, wid, hei, fill, outfill, title="none", webpage="none", lt=1, alpha=1.0, alpha2=1.0):
        self.out += ' <a href="%s">\n' % webpage
        self.out += '  <rect stroke="%s" stroke-opacity="%f" stroke-alignment="inner"\n' % (colorstr(outfill), alpha)
        self.out += '        fill="%s" fill-opacity="%f"\n' % (colorstr(fill), alpha2)
        self.out += '        x="%d" y="%d" width="%d" height="%d"> <title>%s</title> </rect>\n' % (x1, y1, wid, hei, title)
        self.out += '</a>\n\n'


    # create a group of objects in the SVG. This is used for being able to highlight all blocks of the same colinear region at once
    def create_group(self, name, the_class='bar'):
        self.out += '        <g id="%s" class="%s" fill="none">\n' % (name, the_class)

    # close the group in the svg
    def close_group(self):
        self.out += '        </g>'

    # create a pattern to use with a "pattern rect" object
    def create_pattern(self, id, fill, pattern, width, line_width):
        fill = colorstr(fill)
        if pattern == 'horizontal':
            self.out += '    <defs>\n'
            self.out += '      <pattern id="%s" width="%d" height="%d" patternUnits="userSpaceOnUse">\n' % (id, width, width)
            self.out += '        <line x1="0" y1="0" x2="%d" y2="0" style="stroke:%s; stroke-width:%d; fill:#FFFFFF" />\n' % (width, fill, line_width)
            self.out += '      </pattern>\n'
            self.out += '   </defs>\n'
        elif pattern == 'forward_diag':
            self.out += '    <defs>\n'
            self.out += '      <pattern id="%s" width="%d" height="%d" patternTransform="rotate(45 0 0)" patternUnits="userSpaceOnUse">\n' % (id, width, width)
            self.out += '        <line x1="0" y1="0" x2="0" y2="%d" style="stroke:%s; stroke-width:%d; fill:#FFFFFF" />\n' % (width, fill, line_width)
            self.out += '      </pattern>\n'
            self.out += '   </defs>\n'
        elif pattern == 'reverse_diag':
            self.out += '    <defs>\n'
            self.out += '      <pattern id="%s" width="%d" height="%d" patternTransform="rotate(135 0 0)" patternUnits="userSpaceOnUse">\n' % (id, width, width)
            self.out += '        <line x1="0" y1="0" x2="0" y2="%d" style="stroke:%s; stroke-width:%d; fill:#FFFFFF" />\n' % (width, fill, line_width)
            self.out += '      </pattern>\n'
            self.out += '   </defs>\n'

    # create a rectangle with a patterned fill. Pattern needs to be created with  create_pattern first
    def drawPatternRect(self, x, y, width, height, id, fill, title="none", webpage="none", lt=1):
        fill = colorstr(fill)
        self.out += '  <rect style="fill:#FFFFFF; stroke: %s; stroke-alignment: inner;"\n' % fill
        self.out += '        x="%d" y="%d" width="%d" height="%d"  />\n' % (x, y, width, height)
        self.out += '  <a href="%s">' % webpage
        self.out += '  <rect style="fill:url(#%s); stroke: %s; stroke-alignment: inner;"\n' % (id, fill)
        self.out += '        x="%d" y="%d" width="%d" height="%d"> <title>%s</title> </rect>\n' % (x, y, width, height, title)
        self.out += '  </a>'

    # draw a symbol at the x, y position
    def drawSymbol(self, x, y, size, fill, symbol, alpha=1.0, lt=1):
        x0 = x - size/2
        x1 = size/8 + x - size/2
        x2 = size/4 + x - size/2
        x3 = size*3/8 + x - size/2
        x4 = size/2 + x - size/2
        x5 = size*5/8 + x - size/2
        x6 = size*3/4 + x - size/2
        x7 = size*7/8 + x - size/2
        x8 = size + x - size/2
        y0 = y - size/2
        y1 = size/8 + y - size/2
        y2 = size/4 + y - size/2
        y3 = size*3/8 + y - size/2
        y4 = size/2 + y - size/2
        y5 = size*5/8 + y - size/2
        y6 = size*3/4 + y - size/2
        y7 = size*7/8 + y - size/2
        y8 = size + y - size/2
        if symbol == 'o':
            self.out += '  <circle stroke="%s" stroke-width="%d" stroke-opacity="%f"\n' % (colorstr((0, 0, 0)), lt, 1)
            self.out += '        fill="%s" fill-opacity="%f"\n' % (colorstr(fill), alpha)
            self.out += '        cx="%d" cy="%d" r="%d" />\n' % (x, y, size/2)
        elif symbol == 'x':
            self.out += '  <polygon fill="%s" stroke="%s" stroke-width="%d" stroke-opacity="%f" fill-opacity="%f"\n' % (colorstr(fill), colorstr((0, 0, 0)), lt, alpha, alpha)
            self.out += '           points="%d,%d %d,%d %d,%d %d,%d %d,%d %d,%d %d,%d %d,%d %d,%d %d,%d %d,%d %d,%d" />\n' % (x0, y2, x2, y0, x4, y2, x6, y0, x8, y2,
                                                                                                                             x6, y4, x8, y6, x6, y8, x4, y6, x2, y8,
                                                                                                                             x0, y6, x2, y4)
        elif symbol == '+':
            self.out += '  <polygon fill="%s" stroke="%s" stroke-width="%d" stroke-opacity="%f" fill-opacity="%f"\n' % (colorstr(fill), colorstr((0, 0, 0)), lt, alpha, alpha)
            self.out += '           points="%d,%d %d,%d %d,%d %d,%d %d,%d %d,%d %d,%d %d,%d %d,%d %d,%d %d,%d %d,%d" />\n' % (x2, y0, x6, y0, x6, y2, x8, y2, x8, y6,
                                                                                                                             x6, y6, x6, y8, x2, y8, x2, y6, x0, y6,
                                                                                                                             x0, y2, x2, y2)
        elif symbol == 's':
            self.out += '  <polygon fill="%s" stroke="%s" stroke-width="%d" stroke-opacity="%f" fill-opacity="%f"\n' % (colorstr(fill), colorstr((0, 0, 0)), lt, alpha, alpha)
            self.out += '           points="%d,%d %d,%d %d,%d %d,%d" />\n' % (x0, y0, x0, y8, x8, y8, x8, y0)
        elif symbol == '^':
            self.out += '  <polygon fill="%s" stroke="%s" stroke-width="%d" stroke-opacity="%f" fill-opacity="%f"\n' % (colorstr(fill), colorstr((0, 0, 0)), lt, alpha, alpha)
            self.out += '           points="%d,%d %d,%d %d,%d %d,%d %d,%d %d,%d" />\n' % (x0, y0, x2, y0, x4, y4, x6, y0, x8, y0, x4, y8)
        elif symbol == 'v':
            self.out += '  <polygon fill="%s" stroke="%s" stroke-width="%d" stroke-opacity="%f" fill-opacity="%f"\n' % (colorstr(fill), colorstr((0, 0, 0)), lt, alpha, alpha)
            self.out += '           points="%d,%d %d,%d %d,%d %d,%d %d,%d %d,%d" />\n' % (x0, y8, x2, y8, x4, y4, x6, y8, x8, y8, x4, y0)
        elif symbol == 'u':
            self.out += '  <polygon fill="%s" stroke="%s" stroke-width="%d" stroke-opacity="%f" fill-opacity="%f"\n' % (colorstr(fill), colorstr((0, 0, 0)), lt, alpha, alpha)
            self.out += '           points="%d,%d %d,%d %d,%d" />\n' % (x0, y8, x4, y0, x8, y8)
        elif symbol == 'd':
            self.out += '  <polygon fill="%s" stroke="%s" stroke-width="%d" stroke-opacity="%f" fill-opacity="%f"\n' % (colorstr(fill), colorstr((0, 0, 0)), lt, alpha, alpha)
            self.out += '           points="%d,%d %d,%d %d,%d" />\n' % (x0, y0, x4, y8, x8, y0)
        else:
            sys.stderr.write(symbol + '\n')
            sys.stderr.write('Symbol not found, this should not happen.. exiting')
            sys.exit()

    # create a small webpage with information about each block
    def create_subpage(self, webpage, block):
        with open(webpage, 'w') as o:
            o.write("""<!DOCTYPE html>
<html>
<head>

<style>
table {
  font-family: "Verdana", Helvetica, sans-serif;
  border: 1px solid #FFFFFF;
  width: 350px;
  height: 200px;
  text-align: center;
  border-collapse: collapse;
}
table td, table.paleBlueRows th {
  border: 1px solid #FFFFFF;
  padding: 3px 2px;
}
table tbody td {
  font-size: 13px;
}

table tbody td:first-child {
  font-weight: bold
}
table tr:nth-child(even) {
  background: #D0E4F5;
}
table thead {
  background: #0B6FA4;
  border-bottom: 5px solid #FFFFFF;
}
table thead th {
  font-size: 17px;
  font-weight: bold;
  color: #FFFFFF;
  text-align: center;
  border-left: 2px solid #FFFFFF;
}
table thead th:first-child {
  border-left: none;
}

</style>
</head>
<body>

<table style="width:100%">

<tr><th></th><th>Block details</th></tr>
""")
            o.write("<tr><td>fasta</td>\n" + \
            "<td>" + str(block.fasta) + "</td></tr>\n" + \
            "<tr><td>contig</td>\n" + \
            "<td>" + str(block.contig) + "</td></tr>\n" + \
            "<tr><td>start</td>\n" + \
            "<td>" + str(block.start) + "</td></tr>\n" + \
            "<tr><td>length</td>\n" + \
            "<td>" + str(block.length) + "</td></tr>\n" + \
            "<tr><td>strand</td>\n" + \
            "<td>" + str(block.strand) + "</td></tr>\n" + \
            "<tr><td>type</td>\n" + \
            "<td>" + str(block.type) + "</td></tr>\n" + \
            "<tr><td>seq</td>\n" + \
            "<td style=\"font-family: monospace\">")
            for x in range(0, len(block.seq), 60):
                o.write(block.seq[x:x+60] + ' <br>\n')
            o.write("</td></tr>\n" + \
            """    
            </table>

</body>
</html>""")


    # insert string into svg
    def writeString(self, thestring, x, y, size, justify='left'):
        self.out += '  <text\n'
        self.out += '    style="font-size:%dpx;font-style:normal;font-weight:normal;z-index:10\
;line-height:125%%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"\n' % size
        if justify == 'right':
            self.out += '    text-anchor="end"\n'
        elif justify == 'middle':
            self.out += '    text-anchor="middle"\n'
        self.out += '    x="%d"\n' % x
        self.out += '    y="%d"\n' % y
        self.out += '    linespacing="125%"'
        self.out += '>' + thestring + '</text>\n'

# convert HSL value to RGB
def hsl_to_rgb(h, s, l):
    c = (1 - abs(2*l - 1)) * s
    x = c * (1 - abs(h *1.0 / 60 % 2 - 1))
    m = l - c/2
    if h < 60:
        r, g, b = c + m, x + m, 0 + m
    elif h < 120:
        r, g, b = x + m, c+ m, 0 + m
    elif h < 180:
        r, g, b = 0 + m, c + m, x + m
    elif h < 240:
        r, g, b, = 0 + m, x + m, c + m
    elif h < 300:
        r, g, b, = x + m, 0 + m, c + m
    else:
        r, g, b, = c + m, 0 + m, x + m
    r = int(r * 255)
    g = int(g * 255)
    b = int(b * 255)
    return (r,g,b)




# take FASTA or genbank input and prepare it for SIBELIA
# changes header to >A_B where A is the input fasta number and B is the contig number
# this is done because sibelia only takes a multifasta as input, so an easy way to distinguish between contigs in the same fasta
# and contigs in separate fastas is needed
def write_fasta_sibel(fasta_list, out_fasta):
    getfa = False
    getgb = False
    out_dict = {} # records original fasta and contig names
    length_dict = {} # records contig lengths
    seq_dict = {} # records the actual sequence
    with open(out_fasta, 'w') as out:
        for num, fasta in enumerate(fasta_list):
            length_dict[str(num)] = {}
            seq_dict[str(num)] = {}
            with open(fasta) as f:
                count = 0
                for line in f:
                    if line.startswith('>'):
                        out.write('>' + str(num) + '_' + str(count) + '\n')
                        out_dict[str(num) + '_' + str(count)] = (os.path.basename(fasta), line.split()[0][1:])
                        length_dict[str(num)][str(count)] = 0
                        seq_dict[str(num)][str(count)] = ''
                        count += 1
                        getfa = True
                    elif getfa:
                        out.write(line.rstrip() + "\n")
                        length_dict[str(num)][str(count-1)] += len(line.rstrip())
                        seq_dict[str(num)][str(count - 1)] += line.rstrip()
                    elif line.startswith('LOCUS '):
                        name = line.split()[1]
                    elif line.startswith('ORIGIN'):
                        out.write('>' + str(num) + '_' + str(count) + '\n')
                        out_dict[str(num) + '_' + str(count)] = (os.path.basename(fasta), name)
                        length_dict[str(num)][str(count)] = 0
                        seq_dict[str(num)][str(count)] = ''
                        count += 1
                        getgb = True
                    elif line.startswith('//'):
                        getgb = False
                    elif getgb:
                        out.write(''.join(line.split()[1:]) + '\n')
                        length_dict[str(num)][str(count-1)] += len(''.join(line.split()[1:]))
                        seq_dict[str(num)][str(count-1)] += ''.join(line.split()[1:])
    return out_dict, length_dict, seq_dict


# run sibelia
def run_sibel(in_fasta, sibel_dir, sibelia_path, sib_mode, min_block, skip_sibel):
    import shutil
    if shutil.which(sibelia_path) is None:
        sys.stderr.write("Sibelia not found, please direct to sibelia binary with -s, or include in path.")
        sys.exit(0)
    if not skip_sibel:
        subprocess.Popen(sibelia_path + ' -s ' + sib_mode + ' -m ' + str(min_block) + ' -o ' + sibel_dir + ' ' + in_fasta, shell=True).wait()


# class for block objects produced by Sibelia or found in MAF file
class block_object:
    def __init__(self, start, strand, length, block, genes, cat, type=None, fasta=None, contig=None, seq=None):
        self.start = start
        self.strand = strand
        self.length = length
        self.block = block
        self.genes = genes
        self.type = type
        self.cat = cat
        self.fasta = fasta
        self.contig = contig
        self.seq = seq


# get colinear blocks from a MAF
def get_blocks_maf(maf_file, name_dict, gene_list, min_block_size, cats={}):
    header_dict = {}
    fasta_count = set()
    for i in name_dict:
        fasta_count.add(name_dict[i][0])
        header_dict[name_dict[i][1]] = i.split('_')
    fasta_count = len(fasta_count)
    block_dict = {}
    block_count = 0
    get_block = False
    with open(maf_file) as f:
        for line in f:
            if len(line.split()) > 0 and line.split()[0] == 'a':
                get_block = True
                fastaset = set()
                alignments = []
                block_count += 1
                repeat = False
                maxsize = 0
            elif line.rstrip() == '' and get_block:
                get_block = False
                if maxsize < min_block_size:
                    continue
                # if block is found more than once type == repeat
                if repeat:
                    block_type = 'repeat'
                # if block is found exactly as many times as there are references, and there are no repeats, block type == core
                elif len(fastaset) == fasta_count:
                    block_type = 'core'
                # else block type is noncore
                else:
                    block_type = 'noncore'
                for i in alignments:
                    fasta, contig, start, end, strand = i
                    genes = []
                    # find position of the genes in the block
                    for j in gene_list:
                        if fasta + '_' + contig == j[0] and start <= j[2] <= end:
                            genes.append([j[1], j[2] - start])
                    cat = 'none'
                    if fasta + '_' + contig in cats:
                        for q in cats[fasta + '_' + contig]:
                            if q[0] == 'all':
                                cat = q[2]
                            elif q[0] <= start <= end <= q[1]:
                                cat = q[2]
                            elif start <= q[0] <= q[1] <= end:
                                if (q[1] - q[0]) / (end - start) >= 0.5:
                                    cat = q[2]
                            elif start <= q[0] <= end:
                                if (end - q[0]) / (end - start) >= 0.5:
                                    cat = q[2]
                            elif start <= q[1] <= end:
                                if (q[1] - start) / (end - start) >= 0.5:
                                    cat = q[2]
                    if not fasta in block_dict:
                        block_dict[fasta] = {}
                    if not contig in block_dict[fasta]:
                        block_dict[fasta][contig] = []
                    block_dict[fasta][contig].append(block_object(start, strand, end - start, str(block_count), genes, cat, block_type))
            elif line.rstrip() == '':
                pass
            elif line.split()[0] == 's' and get_block:
                header, start, length, strand = line.split()[1:5]
                start, length = int(start), int(length)
                if length > maxsize:
                    maxsize = length
                if header in header_dict:
                    fasta, contig = header_dict[header]
                elif '.'.join(header.split('.')[1:]) in header_dict:
                    fasta, contig = header_dict['.'.join(header.split('.')[1:])]
                else:
                    sys.exit("chromatiblock does not understand how the header in the MAF relates to the header in the FASTAs, please file a bug report.")
                if fasta in fastaset:
                    repeat = True
                fastaset.add(fasta)
                if strand == '+':
                    end = start + length
                else:
                    end = start - length
                    start, end = end, start
                alignments.append((fasta, contig, start, end, strand))
    for i in block_dict:
        for j in block_dict[i]:
            block_dict[i][j].sort(key=lambda x: x.start)
    return(block_dict)

# get blocks from Sibelia output
def get_blocks(sibel_dir, name_dict, seq_dict, gene_list, cats={}):
    seq_no_dict = {}
    block_dict = {}
    block_type = {}
    with open(sibel_dir + '/blocks_coords.txt') as f:
        f.readline()
        get_seq_ids = True
        for line in f:
            if line.startswith('---') and get_seq_ids:
                get_seq_ids = False
            elif line.startswith('---'):
                if repeat:
                    block_type[block] = 'repeat'
                elif len(in_fasta_set) == len(length_dict):
                    block_type[block] = 'core'
                else:
                    block_type[block] = 'noncore'
            elif get_seq_ids:
                seq_id, length, header = line.split()
                fasta, contig = header.split('_')
                if not fasta in block_dict:
                    block_dict[fasta] = {}
                block_dict[fasta][contig] = []
                seq_no_dict[seq_id] = (fasta, contig)
            elif line.startswith('Seq_id'):
                pass
            elif line.startswith('Block'):
                block = line.split()[1][1:]
                repeat = False
                in_fasta_set = set()
            else:
                id, strand, start, end, length = line.split()
                fasta, contig = seq_no_dict[id]
                length = int(length)
                start = int(start)
                end = int(end)
                genes = []
                if strand == '-':
                    start, end = end, start
                for j in gene_list:
                    if fasta + '_' + contig == j[0] and start <= j[2] <= end:
                        genes.append([j[1], j[2] - start])
                cat = 'none'
                if fasta + '_' + contig in cats:
                    for q in cats[fasta + '_' + contig]:
                        if q[0] == 'all':
                            cat = q[2]
                        elif q[0] <= start <= end <= q[1]:
                            cat = q[2]
                        elif start <= q[0] <= q[1] <= end:
                            if (q[1] - q[0]) / (end - start) >= 0.5:
                                cat = q[2]
                        elif start <= q[0] <= end:
                            if (end - q[0]) / (end - start) >= 0.5:
                                cat = q[2]
                        elif start <= q[1] <= end:
                            if (q[1] - start) / (end - start) >= 0.5:
                                cat = q[2]
                if fasta in in_fasta_set:
                    repeat = True
                else:
                    in_fasta_set.add(fasta)
                block_dict[fasta][contig].append(block_object(start, strand, length, block, genes, cat, None, name_dict[fasta + '_' + contig][0], name_dict[fasta + '_' + contig][1], seq_dict[fasta][contig][start-1:start+length]))
    for i in block_dict:
        for j in block_dict[i]:
            block_dict[i][j].sort(key=lambda x: x.start)
            for k in block_dict[i][j]:
                k.type = block_type[k.block]
    return block_dict


# order the core blocks
def order_blocks_core(block_dict):
    core_order = []
    num = 0
    for j in range(len(block_dict['0'])):
        for k in block_dict['0'][str(j)]:
            if k.type == 'core':
                core_order.append((k.block, k.strand))
                k.order_num = num
                num += 1
    if core_order == []:
        sys.exit("No core blocks found. No regions >1000bp were found once in all genomes. Please use more closely related genomes.")
    core_block_num = num
    for i in range(1, len(block_dict)):
        block_order_dict = {}
        for j in block_dict[str(i)]:
            max_len = 0
            for k in block_dict[str(i)][j]:
                if k.length > max_len and k.type == 'core':
                    best_strand = k.strand
                    best_block = k.block
                    max_len = k.length
                if k.block == core_order[0][0]:
                    best_strand = k.strand
                    best_block = k.block
                    max_len = float('inf')
            if max_len != 0:
                block_order_dict[best_block] = (j, best_strand)
        contig_order = []
        num = 0
        for j in core_order:
            if j[0] in block_order_dict:
                reverse = j[1] == block_order_dict[j[0]][1]
                contig_order.append((block_order_dict[j[0]][0], reverse))
                for k in block_dict[str(i)][block_order_dict[j[0]][0]]:
                    if k.block == core_order[0][0]:
                        start_pos = num
                        break
                    if k.type == 'core':
                        num += 1
        color_num = 0
        for j in contig_order:
            for k in range(len(block_dict[str(i)][j[0]])):
                aninstance = block_dict[str(i)][j[0]][k]
                if aninstance.type == 'core':
                    if j[1]:
                        aninstance.order_num = (color_num + core_block_num - start_pos) % core_block_num
                    else:
                        aninstance.order_num = core_block_num - (color_num + core_block_num - start_pos) % core_block_num
                    color_num += 1
    return block_dict

# get the noncore and unaligned regions between core blocks
def get_noncore(block_dict, length_dict, color_contigs=False):
    core_order = []
    max_coreb_length_dict = {}
    for j in range(len(block_dict['0'])):
        for k in block_dict['0'][str(j)]:
            if k.type == 'core':
                core_order.append((k.block, k.strand))
                max_coreb_length_dict[k.block] = 0
    out_blocks = []
    for i in block_dict:
        for j in block_dict[i]:
            last_core = None
            last_core_ori = None
            last_core_end_pos = 0
            noncore_block = []
            for k in block_dict[i][j]:
                if k.type == 'core':
                    length_noncore = k.start - last_core_end_pos
                    if k.length > max_coreb_length_dict[k.block]:
                        max_coreb_length_dict[k.block] = k.length
                    positions = []
                    for num, l in enumerate(core_order):
                        if l[0] == last_core and last_core_ori == l[1]:
                            positions.append((num+1, 'left', True))
                        elif l[0] == last_core:
                            positions.append((num, 'right', False))
                        elif l[0] == k.block and k.strand == l[1]:
                            positions.append((num, 'right', True))
                        elif l[0] == k.block:
                            positions.append((num+1, 'left', False))
                    if len(positions) > 2:
                        sys.exit('something went wrong')
                    out_blocks.append((i, noncore_block, length_noncore, positions))
                    last_core = k.block
                    last_core_end_pos = k.start + k.length
                    last_core_ori = k.strand
                    noncore_block = []
                else:
                    if color_contigs:
                        k.cat = j
                    noncore_block.append((k.start - last_core_end_pos, k.strand, k.length, k.block, k.type, k.genes, k.cat, k))
            if last_core is None:
                out_blocks.append((i, noncore_block, length_dict[i][j], []))
            elif k.type != 'core':
                positions = []
                for num, l in enumerate(core_order):
                    if l[0] == last_core and last_core_ori == l[1]:
                        positions.append((num+1, 'left', True))
                    elif l[0] == last_core:
                        positions.append((num+2, 'right', False))
                out_blocks.append((i, noncore_block, length_dict[i][j] - last_core_end_pos, positions))
    return out_blocks

# get position for each of the core blocks
def place_core(block_dict, color_contigs=False):
    core_order = {}
    count = 0
    for j in range(len(block_dict['0'])):
        for k in block_dict['0'][str(j)]:
            if k.type == 'core':
                core_order[k.block] = count
                count += 1
    out_array = [[] for i in range(len(core_order))]
    max_coreb_length = [0 for i in range(len(core_order))]
    for i in range(len(block_dict)):
        for j in block_dict[str(i)]:
            for k in block_dict[str(i)][j]:
                if k.type == 'core':
                    if color_contigs:
                        out_array[core_order[k.block]].append((k.length, j, k))
                    else:
                        out_array[core_order[k.block]].append((k.length, k.order_num, k))
                    if k.length > max_coreb_length[core_order[k.block]]:
                        max_coreb_length[core_order[k.block]] = k.length
    return out_array, max_coreb_length

# gets position for each of the noncore regions
def place_noncore(out_blocks):
    placed_blocks = []
    unplaced_blocks = []
    block_loc = {}
    for i in out_blocks:
        row, pattern, size, positions = i
        if size == 0:
            continue
        right_place = None
        left_place = None
        # get the core blocks either side of the noncore region
        for j in positions:
            if j[1] == 'left':
                left_place = j[0]
                left_ori = j[2]
            else:
                right_place = j[0]
                right_ori = j[2]
        placed = False
        # if core blocks both sides of the noncore region are adjacent to each other, place it in the middle
        if left_place == right_place and not left_place is None:
            placed = True
            if left_ori:
                placed_blocks.append((row, pattern, size, left_place, 'middle'))
            else:
                new_pattern = []
                for j in pattern:
                    start, strand, length, block, block_type, genes, cat, block_obj = j
                    start = size - (start + length)
                    for k in genes:
                        k[1] = length - k[1]
                    new_pattern.append((start, strand, length, block, block_type, genes, cat, block_obj))
                placed_blocks.append((row, new_pattern, size, left_place, 'middle'))
        elif left_place is None and not right_place is None:
            placed = True
            if right_ori:
                placed_blocks.append((row, pattern, size, right_place, 'right'))
            else:
                new_pattern = []
                for j in pattern:
                    start, strand, length, block, block_type, genes, cat, block_obj = j
                    start = size - (start + length)
                    for k in genes:
                        k[1] = length - k[1]
                    new_pattern.append((start, strand, length, block, block_type, genes, cat, block_obj))
                placed_blocks.append((row, new_pattern, size, left_place, 'right'))
        # if no right place is found
        elif not left_place is None and right_place is None:
            placed = True
            if left_ori:
                placed_blocks.append((row, pattern, size, right_place, 'left'))
            else:
                new_pattern = []
                for j in pattern:
                    start, strand, length, block, block_type, genes, cat, block_obj = j
                    start = size - (start + length)
                    for k in genes:
                        k[1] = length - k[1]
                    new_pattern.append((start, strand, length, block, block_type, genes, cat, block_obj))
                placed_blocks.append((row, new_pattern, size, left_place, 'left'))
        # add location for placed block
        if placed:
            for j in placed_blocks[-1][1]:
                if j[4] == 'noncore':
                    if not placed_blocks[-1][3] in block_loc:
                        block_loc[placed_blocks[-1][3]] = set()
                    block_loc[placed_blocks[-1][3]].add(j[3])
        else:
            unplaced_blocks.append(i)
    for i in unplaced_blocks:
        row, pattern, size, positions = i
        if positions == []:
            placed_blocks.append((row, pattern, size, None, None))
        else:
            for j in positions:
                if j[1] == 'left':
                    left_place = j[0]
                    left_ori = j[2]
                else:
                    right_place = j[0]
                    right_ori = j[2]
            left_count = 0
            right_count = 0
            for j in pattern:
                if right_place in block_loc and j[3] in block_loc[right_place]:
                    right_count += 1
                if left_place in block_loc and j[3] in block_loc[left_place]:
                    left_count += 1
            if left_count > right_count or right_count == left_count and left_place < right_place:
                if left_ori:
                    placed_blocks.append((row, pattern, size, right_place, 'left'))
                else:
                    new_pattern = []
                    for j in pattern:
                        start, strand, length, block, block_type, genes, cat, block_obj = j
                        start = size - (start + length)
                        for k in genes:
                            k[1] = length - k[1]
                        new_pattern.append((start, strand, length, block, block_type, genes, cat, block_obj))
                    placed_blocks.append((row, new_pattern, size, left_place, 'left'))
            else:
                if right_ori:
                    placed_blocks.append((row, pattern, size, right_place, 'right'))
                else:
                    new_pattern = []
                    for j in pattern:
                        start, strand, length, block, block_type, genes, cat, block_obj = j
                        start = size - (start + length)
                        for k in genes:
                            k[1] = length - k[1]
                        new_pattern.append((start, strand, length, block, block_type, genes, cat, block_obj))
                    placed_blocks.append((row, new_pattern, size, left_place, 'right'))
    return placed_blocks


# Draw the block to an SVG or html (then convert svg to pdf or png)
def draw_blocks(core_blocks, placed_blocks, core_size, out_file, output_format, block_height, y_gap, legend_size, working_dir, ppi, color_cat=True,
                svg_pan_zoom_location='http://ariutta.github.io/svg-pan-zoom/dist/svg-pan-zoom.min.js', hue_start=0, hue_stop=360, texta="chromatiblock figure",
                textb="This figure was create with chromatiblock - https://github.com/mjsull/chromatiblock.", color_contigs=False, add_labels=None):
    noncore_max_size = [0 for i in range(len(core_blocks) + 2)]
    unattached_size = [[] for i in range(len(core_blocks[0]))]
    figure_width = 50000
    genome_height = block_height + y_gap
    genome_line_width = block_height/8
    height = (len(core_blocks[0]) + 3 + legend_size/2) * genome_height * 2
    core_sat = 0.8
    core_light = 0.5
    # create the html or svg image
    if output_format == 'html':
        svg = scalableVectorGraphicsHTML(height, figure_width, False, svg_pan_zoom_location, texta)
    else:
        if add_labels is None:
            svg = scalableVectorGraphicsHTML(height, figure_width, True)
        else:
            svg = scalableVectorGraphicsHTML(height, figure_width + 10000, True)
    for i in placed_blocks:
        row, pattern, size, place, align = i
        if place is None:
            unattached_size[int(row)].append(size)
        elif size > noncore_max_size[place]:
            noncore_max_size[place] = size

    curr_x = 0
    gap_size = 20
    max_unattached = 0
    max_unattached_num = 0
    for i in unattached_size:
        if sum(i) > max_unattached:
            max_unattached = sum(i)
            max_unattached_num = len(i)
    usable_length = figure_width - gap_size * 2 * (len(core_blocks) + max_unattached_num - 1)
    bp = sum(core_size) + sum(noncore_max_size) + max_unattached
    scale = bp / usable_length
    gap_pos = {}
    pgnm = 0
    # draw the core blocks in panel A
    for num1, i in enumerate(core_blocks):
        gap_pos[num1] = curr_x
        curr_x += noncore_max_size[num1] / scale + gap_size * 2
        for num2, j in enumerate(i):
            width, block_no, block = j
            if color_contigs:
                color1 = color_list[int(block_no)]
                color2 = color_list[int(block_no)]
            else:
                hue = hue_start + int(block_no * 1.0 / len(core_size) * (hue_stop - hue_start))
                color1 = hsl_to_rgb(hue, core_sat, core_light)
                color2 = hsl_to_rgb(hue, core_sat, core_light - 0.3)
            svg.drawOutRect(curr_x, num2 * genome_height, width/scale, block_height, color1, color2, "block " + block.block + ':' + block.contig + ':' + str(block.start) + '..' + str(block.start + block.length), "%s_files/%d.html" % (out_file, pgnm))
            if output_format == 'html':
                svg.create_subpage("%s_files/%d.html" % (out_file, pgnm), block)
            pgnm += 1
        curr_x += core_size[num1] / scale
    gap_pos[num1+1] = curr_x
    noncore_dict = {}
    unplaced_start = curr_x + gap_size * 10
    placed_blocks.sort(key=lambda x: x[2], reverse=True)
    unplaced_taken = {}
    # for each placed noncore section draw line and then get positions for each block in that section
    for i in placed_blocks:
        row, pattern, size, gap, align = i
        if gap is None:
            if row in unplaced_taken:
                x1 = unplaced_taken[row]
            else:
                x1 = unplaced_start
            x2 = x1 + size/scale
            unplaced_taken[row] = x2 + gap_size * 2
        elif align == 'left':
            x1 = gap_pos[gap]
            x2 = gap_pos[gap] + size/scale
        elif align == 'middle':
            x1 = gap_pos[gap] + gap_size + noncore_max_size[gap]/scale/2 - size/scale/2
            x2 = gap_pos[gap] + gap_size + noncore_max_size[gap]/scale/2 - size/scale/2 + size/scale
        elif align == 'right':
            x1 = gap_pos[gap] + noncore_max_size[gap]/scale - size/scale + 2 * gap_size
            x2 = gap_pos[gap] + noncore_max_size[gap]/scale + 2 * gap_size
        y = int(row) * genome_height + block_height / 2
        svg.drawLine(x1, y, x2, y, th=genome_line_width)
        for j in pattern:
            start, strand, length, block, block_type, genes, cat, block_obj = j
            if block in noncore_dict:
                noncore_dict[block].append((row, x1 + start/scale, length, genes, cat, block_obj))
            else:
                noncore_dict[block] = [(row, x1 + start/scale, length, genes, cat, block_obj)]
    noncore_order = []
    # get order for panel B
    for i in noncore_dict:
        pos_list = []
        for j in noncore_dict[i]:
            pos_list.append(j[1])
        pos_list.sort()
        noncore_order.append((pos_list[len(pos_list)//2], i))
    noncore_order.sort()
    block_order = []
    for i in noncore_order:
        block_order.append(i[1])
    curr_x = 0
    panel2_start = len(core_blocks[0]) * genome_height + genome_height * 4
    gene_dict_a = {}
    gene_dict_b = {}
    pattern_dict = {}
    cat_count = 0
    bp_blocks = 0
    block_count = {}
    # get the maximum block size for each column
    for num, i in enumerate(block_order):
        block_count[i] = {}
        max_block_width = 0
        for j in noncore_dict[i]:
            row, x, length, genes, cat, block = j
            if row in block_count[i]:
                block_count[i][row][0] += 1
            else:
                block_count[i][row] = [1, 0]
            if length > max_block_width:
                max_block_width = length
        bp_blocks += max_block_width
    scale2 = bp_blocks / (figure_width - gap_size * (len(block_order) - 1))
    cat_list = []
    font_size = genome_height * 0.7
    # add fasta labels to figure
    if not add_labels is None:
        for num, row in enumerate(add_labels):
            svg.writeString(row, 52000, (num+0.75) * genome_height, font_size)
            svg.writeString(row, 52000, (num+0.75) * genome_height + panel2_start, font_size)
    for num, i in enumerate(block_order):
        # create an id and pattern for each non-core block
        id = 'g' + str(num)
        if not color_contigs:
            color = color_list[num % len(color_list)]
            pattern = pattern_list[num % len(pattern_list)]
            svg.create_pattern(id, color, pattern, 50, 50)
            pattern_dict[id]= color
            if color_cat:
                for j in noncore_dict[i]:
                    row, x, length, genes, cat, block = j
                    id2 = cat
                    if not id2 in pattern_dict:
                        color2 = color_list[cat_count % len(color_list)]
                        cat_count += 1
                        cat_list.append(id2)
                        pattern = pattern_list[cat_count % len(pattern_list)]
                        svg.create_pattern(id2, color2, pattern, 50, 50)
                        pattern_dict[id2] = color2
        max_block_width = 0
        # create a group for the non-core block and then draw all instances of that block
        svg.create_group('gr' + str(num))
        for j in noncore_dict[i]:
            row, x, length, genes, cat, block = j
            if color_cat:
                id2 = cat
                color2 = pattern_dict[id2]
            else:
                id2 = id
                color2 = color
            for k in genes:
                if k[0] in gene_dict_a:
                    gene_dict_a[k[0]].append((x + k[1]/scale, int(row)))
                    gene_dict_b[k[0]].append((curr_x + k[1]/scale2, curr_x -gap_size/2, int(row)))
                else:
                    gene_dict_a[k[0]] = [(x + k[1]/scale, int(row))]
                    gene_dict_b[k[0]] = [(curr_x + k[1]/scale2, curr_x -gap_size/2, int(row))]
            svg.drawPatternRect(x, int(row) * genome_height, length/scale, block_height, id, color, "block " +
                                block.block + ':' + block.contig + ':' + str(block.start) + '..' + str(block.start + block.length), "%s_files/%d.html" % (out_file, pgnm))
            block_height_2 = block_height/block_count[i][row][0]
            svg.drawPatternRect(curr_x, int(row) * genome_height + panel2_start + block_height_2 * block_count[i][row][1],
                                length/scale2, block_height_2, id2, color2, "block " + block.block + ':' + block.contig +
                                ':' + str(block.start) + '..' + str(block.start + block.length), "%s_files/%d.html" % (out_file, pgnm))
            if output_format == 'html':
                svg.create_subpage("%s_files/%d.html" % (out_file, pgnm), block)
            pgnm += 1
            block_count[i][row][1] += 1
            if length/scale2 + gap_size > max_block_width:
                max_block_width = length/scale2 + gap_size
        curr_x += max_block_width
        svg.close_group()
    svg.create_group('annot', 'anno')
    color_list.reverse()
    # add genes to panel a
    for num, i in enumerate(gene_dict_a):
        color = color_list[num % len(color_list)]
        for j in gene_dict_a[i]:
            x, y = j
            y = y * genome_height + genome_height/2
            svg.drawSymbol(x, y, block_height*3/4, color, 'd', alpha=1.0, lt=10)
    # add genes ot panel b
    for num, i in enumerate(gene_dict_b):
        color = color_list[num % len(color_list)]
        for j in gene_dict_b[i]:
            x1, x2, y = j
            y = y * genome_height + genome_height / 2 + panel2_start
            svg.drawSymbol(x1, y, block_height/2, color, 'd', alpha=1.0, lt=10)
    svg.close_group()
    legend_start = (len(core_blocks[0]) + 3) * genome_height * 2
    curr_y = legend_start

    # depending on the size of the figure, create the appropriately sized scale figure
    if bp < 100000:
        scale1size = 5000
        scale1txt = "5 Kbp"
    elif bp <= 500000:
        scale1size = 10000
        scale1txt = "10 Kbp"
    elif bp <= 1000000:
        scale1size = 50000
        scale1txt = "50 Kbp"
    elif bp <= 5000000:
        scale1size = 100000
        scale1txt = "100 Kbp"
    elif bp <= 10000000:
        scale1size = 500000
        scale1txt = "500 Kbp"
    elif bp <= 50000000:
        scale1size = 1000000
        scale1txt = "1 Mbp"
    elif bp <= 100000000:
        scale1size = 5000000
        scale1txt = "5 Mbp"
    else:
        scale1size = 10000000
        scale1txt = "10 Mbp"
    if bp_blocks < 100000:
        scale2size = 5000
        scale2txt = "5 Kbp"
    elif bp_blocks <= 500000:
        scale2size = 10000
        scale2txt = "10 Kbp"
    elif bp_blocks <= 1000000:
        scale2size = 50000
        scale2txt = "50 Kbp"
    elif bp_blocks <= 5000000:
        scale2size = 100000
        scale2txt = "100 Kbp"
    elif bp_blocks <= 10000000:
        scale2size = 500000
        scale2txt = "500 Kbp"
    elif bp_blocks <= 50000000:
        scale2size = 1000000
        scale2txt = "1 Mbp"
    elif bp_blocks <= 100000000:
        scale2size = 5000000
        scale2txt = "5 Mbp"
    else:
        scale2size = 10000000
        scale2txt = "10 Mbp"
    svg.drawLine(50, curr_y+block_height/2, 50 + scale1size / scale, curr_y+block_height/2, genome_line_width, (0, 0, 0))
    svg.drawLine(50, curr_y, 50, curr_y + block_height, genome_line_width, (0,0,0))
    svg.drawLine(50 + scale1size / scale, curr_y, 50 + scale1size / scale, curr_y + block_height, genome_line_width, (0,0,0))
    svg.writeString(scale1txt + ' (panel a)', 50, curr_y + genome_height + font_size, font_size)
    curr_y += genome_height * 2.1
    svg.drawLine(50, curr_y + block_height/2, 50 + scale2size / scale2, curr_y+block_height/2, genome_line_width, (0, 0, 0))
    svg.drawLine(50, curr_y, 50, curr_y + block_height, genome_line_width, (0,0,0))
    svg.drawLine(50 + scale2size / scale2, curr_y, 50 + scale2size / scale2, curr_y + block_height, genome_line_width, (0,0,0))
    svg.writeString(scale2txt + ' (panel b)', 50, curr_y + genome_height+font_size, font_size)
    curr_y += genome_height * 2.1
    # if creating a webpage seperate the svg out into main figure (scrollable) and legend.
    if output_format == 'html':
        svg.seperate_figure(width, legend_size * genome_height)
        curr_y = 0
        legend_start = 0
    # create legend for categories
    if color_cat:
        svg.writeString("Block categories", figure_width / 2, legend_start + 3 * genome_height / 4, font_size)
    for num, i in enumerate(cat_list):
        svg.drawPatternRect(figure_width / 2, legend_start + (num + 1) * genome_height, figure_width / 100,
                            block_height, i, pattern_dict[i])
        svg.writeString(i, figure_width / 2 + figure_width / 100,
                        legend_start + (num + 1) * genome_height + 3 * genome_height / 4, font_size)
    # create legend for genes
    if len(gene_dict_b) > 0:
        svg.writeString("Genes", figure_width / 4, legend_start + 3 * genome_height / 4, font_size)
    for num, i in enumerate(gene_dict_b):
        color = color_list[num % len(color_list)]
        svg.drawSymbol(figure_width / 4, legend_start + (num + 1) * genome_height + block_height / 2, block_height / 2,
                       color, 'd', alpha=1.0, lt=10)
        svg.writeString(i, figure_width / 4 + block_height / 2,
                        legend_start + (num + 1) * genome_height + 3 * genome_height / 4, font_size)
    svg.writeString('Position of core block in genome', 50 + figure_width / 20, curr_y + font_size,
                    font_size, justify='middle')
    curr_y += font_size * 1.5
    # create elements of the legend that will always appear
    svg.drawHueGradient(50, curr_y, figure_width/10, genome_height, core_sat, core_light, hue_start, hue_stop)
    svg.writeString('start', 50, curr_y + genome_height + font_size, font_size)
    svg.writeString('end', 50+figure_width/10, curr_y + genome_height + font_size, font_size, justify='right')
    curr_y += genome_height * 2.1
    color = hsl_to_rgb(0, core_sat, core_light)
    out_color = hsl_to_rgb(0, core_sat, max([core_light - 0.2, 0]))
    svg.drawOutRect(50, curr_y, figure_width / 100, genome_height, color, out_color)
    color = hsl_to_rgb(200, core_sat, core_light)
    out_color = hsl_to_rgb(200, core_sat, max([core_light - 0.2, 0]))
    svg.drawOutRect(figure_width / 100 + 50 + gap_size, curr_y, figure_width / 200, genome_height, color, out_color)
    svg.writeString('Core blocks', 50, curr_y + genome_height + font_size, font_size)
    curr_y += genome_height * 2.1
    color = color_list[12]
    pattern = pattern_list[0]
    svg.create_pattern('leg1', color, pattern, 50, 50)
    svg.drawPatternRect(50, curr_y, figure_width/100, genome_height, 'leg1', color, 1)
    color = color_list[13]
    pattern = pattern_list[1]
    svg.create_pattern('leg2', color, pattern, 50, 50)
    svg.drawPatternRect(figure_width/100 + 50 +gap_size, curr_y, figure_width/200, genome_height, 'leg2', color, 1)
    svg.writeString('Non-core blocks', 50, curr_y + genome_height + font_size, font_size)
    curr_y += genome_height * 2.1
    svg.drawLine(50, curr_y + genome_height/2, figure_width/100, curr_y + genome_height/2, genome_line_width)
    svg.drawLine(figure_width/100 + 50 + gap_size, curr_y + genome_height/2, figure_width/200, curr_y + genome_height/2, genome_line_width)
    svg.writeString('Unaligned sequence', 50, curr_y + genome_height + font_size, font_size)
    curr_y += genome_height * 2.1
    color = hsl_to_rgb(0, core_sat, core_light)
    out_color = hsl_to_rgb(0, core_sat, max([core_light - 0.2, 0]))
    svg.drawOutRect(50, curr_y, figure_width/100, genome_height, color, out_color)
    svg.drawLine(figure_width/100+50, curr_y + genome_height/2, 50+3*figure_width/100, curr_y + genome_height/2, genome_line_width)
    color = color_list[12]
    svg.drawPatternRect(figure_width/100+50, curr_y, figure_width/100, genome_height, 'leg2', color, 1)
    color = color_list[13]
    svg.drawPatternRect(50+figure_width*5/200, curr_y, figure_width/200, genome_height, 'leg1', color, 1)
    color = hsl_to_rgb(200, core_sat, core_light)
    out_color = hsl_to_rgb(200, core_sat, max([core_light - 0.2, 0]))
    svg.drawOutRect(50 + 3*figure_width/100 + gap_size*2, curr_y, figure_width/100, genome_height, color, out_color)
    svg.writeString('Noncore region adjacent to left core block', 50, curr_y + genome_height + font_size, font_size)
    curr_y += genome_height * 2.1
    color = hsl_to_rgb(0, core_sat, core_light)
    out_color = hsl_to_rgb(0, core_sat, max([core_light - 0.2, 0]))
    svg.drawOutRect(50, curr_y, figure_width / 100, genome_height, color, out_color)
    svg.drawLine(figure_width / 100 + 50 + gap_size, curr_y + genome_height / 2, 50 + gap_size + 3 * figure_width / 100,
                 curr_y + genome_height / 2, genome_line_width)
    color = color_list[12]
    svg.drawPatternRect(figure_width / 100 + 50 + gap_size, curr_y, figure_width / 100, genome_height, 'leg2', color, 1)
    color = color_list[13]
    svg.drawPatternRect(50 + figure_width * 5 / 200 + gap_size, curr_y, figure_width / 200, genome_height, 'leg1', color, 1)
    color = hsl_to_rgb(200, core_sat, core_light)
    out_color = hsl_to_rgb(200, core_sat, max([core_light - 0.2, 0]))
    svg.drawOutRect(50 + 3 * figure_width / 100 + gap_size * 2, curr_y, figure_width / 100, genome_height, color,
                    out_color)
    svg.writeString('Noncore region adjacent to both core blocks', 50, curr_y + genome_height + font_size, font_size)
    curr_y += genome_height * 2.1
    color = hsl_to_rgb(0, core_sat, core_light)
    out_color = hsl_to_rgb(0, core_sat, max([core_light - 0.2, 0]))
    svg.drawOutRect(50, curr_y, figure_width / 100, genome_height, color, out_color)
    svg.drawLine(figure_width / 100 + 50 + 2*gap_size, curr_y + genome_height / 2, 50 + 3 * figure_width / 100 + 2*gap_size,
                 curr_y + genome_height / 2, genome_line_width)
    color = color_list[12]
    svg.drawPatternRect(figure_width / 100 + 50 + 2*gap_size, curr_y, figure_width / 100, genome_height, 'leg2', color, 1)
    color = color_list[13]
    svg.drawPatternRect(50 + figure_width * 5 / 200 + 2*gap_size, curr_y, figure_width / 200, genome_height, 'leg1', color, 1)
    color = hsl_to_rgb(200, core_sat, core_light)
    out_color = hsl_to_rgb(200, core_sat, max([core_light - 0.2, 0]))
    svg.drawOutRect(50 + 3 * figure_width / 100 + gap_size * 2, curr_y, figure_width / 100, genome_height, color,
                    out_color)
    svg.writeString('Noncore region adjacent to right core block', 50, curr_y + genome_height + font_size, font_size)
    # write the output files
    if output_format == 'html':
        svg.writesvg(out_file, False, textb)
    elif output_format == 'svg':
        svg.writesvg(out_file, True)
    elif output_format == 'pdf' or output_format == 'png' or output_format == 'all':
        try:
            if output_format == 'all':
                inital_svg = out_file + '.svg'
            else:
                inital_svg = os.path.join(working_dir, "temp.svg")
            svg.writesvg(inital_svg)
            import cairosvg
            if output_format == 'pdf':
                cairosvg.svg2pdf(url=inital_svg, write_to=out_file, dpi=ppi)

            if output_format == 'all':
                cairosvg.svg2pdf(url=inital_svg, write_to=out_file + '.pdf', dpi=ppi)
                cairosvg.svg2png(url=inital_svg, write_to=out_file + '.png', dpi=ppi)
            if out_file.endswith('.png'):
                cairosvg.svg2png(url=inital_svg, write_to=out_file, dpi=ppi)

        except ImportError:
            sys.exit('cairosvg not found, please install (or install chromatiblock using conda)')
    else:
        sys.stderr.write("unrecognised output format")
        sys.exit(0)


# use blast to assign gene positions
def get_gene_pos(working_dir, genes_faa, skip, num_threads='8', min_ident=90, min_length=0.5):
    if not skip:
        subprocess.Popen('makeblastdb -in ' + genes_faa + ' -out ' + working_dir + '/tempdb -dbtype prot', shell=True).wait()
        subprocess.Popen('blastx -query ' + working_dir + '/input.fasta -db ' + working_dir + '/tempdb -outfmt 6 -num_threads '
                         + num_threads + ' -out ' + working_dir + '/gene_input.out', shell=True).wait()
    len_dict = {}
    with open(genes_faa) as f:
        for line in f:
            if line.startswith('>'):
                name = line.split()[0][1:]
                len_dict[name] = 0
            else:
                len_dict[name] += len(line.rstrip())
    out_list = []
    with open(working_dir + '/gene_input.out') as f:
        for line in f:
            query, subject, ident, length, mismatch, indel, qstart, qstop, rstart, rstop, eval, bitscore = line.split()
            if float(length) >= min_length * len_dict[subject] and float(ident) > min_ident:
                out_list.append((query, subject, int(qstart)))
    return out_list

# get gene positions from a file
def get_gene_file(gene_file, name_dict):
    out_list = []
    with open(gene_file) as f:
        for line in f:
            fasta, contig, gene, pos = line.split()
            for i in name_dict:
                if name_dict[i] == (fasta, contig):
                    out_list.append((i, gene, int(pos)))
    return out_list

# get categories from a file
def get_categories(cat_file, name_dict):
    cats = {}
    with open(cat_file) as f:
        for line in f:
            if len(line.split()) == 5:
                fasta, contig, cat, start, stop = line.split()
                start, stop = int(start), int(stop)
            else:
                fasta, contig, cat = line.split()
                start, stop = 'all', 'all'
            name = None
            for i in name_dict:
                if name_dict[i] == (fasta, contig):
                    name = i
                    break
            if name is None:
                sys.stderr.write(fasta + ' or ' + contig + ' do not exist in alignment.\n')
            elif name in cats:
                cats[name].append((start, stop, cat))
            else:
                cats[name] = [(start, stop, cat)]
    return cats

__version__ = "1.0.0"


parser = argparse.ArgumentParser(prog='chromatiblock %s' % __version__,
    formatter_class=argparse.RawDescriptionHelpFormatter, description='''chromatiblock: Large scale whole genome visualisation using colinear blocks.

Version: ''' + __version__ + '\n\n' + '''License: GPLv3

USAGE: chromatiblock -f genome1.fasta genome2.fasta .... genomeN.fasta -w working_dir -o figure.html 

        or
     
       chromatiblock -d /path/to/fasta_directory/ -w working_dir -o figure.svg -of svg




''', epilog="Thanks for using chromatiblock")

group = parser.add_mutually_exclusive_group(required=True)
group.add_argument('-d', '--input_directory', action='store', help='Directory of fasta files to use as input.')
group.add_argument('-f', '--fasta_files', nargs='+', action='store', help='List of fasta/genbank files to use as input')
parser.add_argument('-l', '--order_list', action='store', help='List of fasta files in desired order.')
parser.add_argument('-w', '--working_directory', action='store', help='Folder to write intermediate files.')
parser.add_argument('-s', '--sibelia_path', action='store', default='Sibelia', help='Specify path to sibelia '
                                                               '(does not need to be set if Sibelia binary is in path).')
parser.add_argument('-sm', '--sibelia_mode', action='store', default='loose', help='mode for running sibelia <loose|fine|far>')
parser.add_argument('-e', '--extensions', action='store', default='fasta,fa,fna,gbk,gb', help="When -d is used for input files, chromatiblock will check against this comma seperated list to determine whether to add file to the list of input sequences.")
parser.add_argument('-o', '--out', action='store', help='Location to write output.')
parser.add_argument('-of', '--output_format', action='store', default='html', help='file format to write to, if all is selected --out will be a prefix and extension will be added', choices=["html", "svg", "png", "pdf", "all"])
parser.add_argument('-q', '--ppi', action='store', type=int, default=600, help="pixels per inch (only used for png, figure width is 8 inches)")
parser.add_argument('-m', '--min_block_size', action='store', type=int, default=1000, help='Minimum size of syntenic block.')
parser.add_argument('-c', '--categorise', action='store', help='color blocks by category')
parser.add_argument('-gb', '--genes_of_interest_blast', action='store', help='mark genes of interest using BLASTx')
parser.add_argument('-gf', '--genes_of_interest_file', action='store', help='mark genes of interest using a file')
parser.add_argument('-gh', '--genome_height', action='store', type=int, default=280, help='Height of genome blocks')
parser.add_argument('-vg', '--gap', action='store', type=int, default=20, help='gap between genomes')
parser.add_argument('-ss', '--skip_sibelia', action='store_true', help="Use sibelia output already in working directory")
parser.add_argument('-sb', '--skip_blast', action='store_true', help="use existing BLASTx file for annotation")
parser.add_argument('-maf', '--maf_alignment', action='store', help="use a maf file for alignment.")
parser.add_argument('-pz', '--svg_pan_zoom_location', action='store', default='http://ariutta.github.io/svg-pan-zoom/dist/svg-pan-zoom.min.js',
                    help='location of svg-pan-zoom.min.js')
parser.add_argument('-v', '--version', action='store_true', help="print version and exit")
parser.add_argument('-hs', '--hue_start', action='store', type=int, default=0)
parser.add_argument('-he', '--hue_end', action='store', type=int, default=360)
parser.add_argument('-t', '--add_fasta_labels', action='store_true', help="add fasta names to figure")
parser.add_argument('--force', action='store_true', help="overwrite working directory and output")
parser.add_argument('--keep', action='store_true', help="keep working directory")


args = parser.parse_args()


if args.version:
    sys.stdout.write('Version %s\n' % __version__)
    sys.exit()


if not 0 <= args.hue_start <= args.hue_end <= 360:
    sys.stderr.write("hue values must be between 0 and 360\n")
    sys.exit(0)

# add sequence files with valid extensions from -d
if not args.input_directory is None:
    fasta_list = []
    for i in os.listdir(args.input_directory):
        abspath = os.path.abspath(os.path.join(args.input_directory + '/' + i))
        if not abspath in fasta_list:
            for j in args.extensions.split(','):
                if abspath.endswith('.' + j):
                    fasta_list.append(abspath)
                    break
elif not args.fasta_files is None:
    fasta_list = args.fasta_files
else:
    sys.stderr.write('No input files found use -f to specify individual FASTA files or -d to specify a directory of FASTA files\n'
                     'chromatiblock also requires a working directory (-w) and an output file (-o)\n\n'
                     'Type --help for descriptions of all flags\n')
    sys.exit(0)


if args.working_directory is None:
    sys.exit("Please specify a working directory.")
elif os.path.exists(args.working_directory) and not os.path.isdir:
    sys.exit("Working directory exists (and is a file)")
elif os.path.exists(args.working_directory) and not args.force:
    sys.exit("Working directory exists, please use --force to overwrite. WARNING: folder will be remove once finished.")
elif not os.path.exists(args.working_directory):
    os.makedirs(args.working_directory)

# create directory for webpages of block information
if args.output_format == 'html':
    if not os.path.exists(args.out + '_files'):
        os.makedirs(args.out + '_files')


if args.out is None:
    sys.exit("Please specify where to write image file.")


# order the fasta files based on stings provided in the order list
if not args.order_list is None:
    with open(args.order_list) as f:
        new_fasta_list = []
        for line in f:
            gotit = False
            for i in fasta_list:
                if line.rstrip() in i:
                    new_fasta_list.append(i)
                    gotit = True
                    break
            if not gotit:
                sys.stderr.write(line + ' not found in input fastas.\n')

    for i in fasta_list:
        if not i in new_fasta_list:
            sys.stderr.write('Could not place ' + i + ' appending to end of figure.\n')
            new_fasta_list.append(i)
    fasta_list = new_fasta_list


# get a list of names, lengths and sequences of the fasta/gbk files and write for processing with sibel
name_dict, length_dict, seq_dict = write_fasta_sibel(fasta_list, args.working_directory + '/input.fasta')

# get gene locations if aa fasta file is provided
if not args.genes_of_interest_blast is None:
    gene_list = get_gene_pos(args.working_directory, args.genes_of_interest_blast, args.skip_blast)
else:
    gene_list = []

# get gene locations if file is provided
if not args.genes_of_interest_file is None:
    gene_list2 = get_gene_file(args.genes_of_interest_file, name_dict)
    gene_list += gene_list2

# get categories if file is provided
if not args.categorise is None:
    cats = get_categories(args.categorise, name_dict)
else:
    cats = {}


# get the size of the legend
cat_set = set()
for i in cats:
    for j in cats[i]:
        cat_set.add(j[2])
gene_set = set()
for i in gene_list:
    gene_set.add(i[1])

legend_size = max([len(gene_set)+1, len(cat_set) + 2, 20])

# get labels for each genome from the fasta file names
if args.add_fasta_labels:
    labels = []
    for i in fasta_list:
        labels.append(os.path.splitext(os.path.basename(i))[0])
else:
    labels = None

# if a maf file isn't provided, run sibelia otherwise get multi-alignments form mAF
if args.maf_alignment is None:
    run_sibel(args.working_directory + '/input.fasta', args.working_directory, args.sibelia_path, args.sibelia_mode, args.min_block_size, args.skip_sibelia)
    block_dict = get_blocks(args.working_directory, name_dict, seq_dict, gene_list, cats)
else:
    block_dict = get_blocks_maf(args.maf_alignment, name_dict, gene_list, args.min_block_size, cats)
order_blocks_core(block_dict)
out_blocks = get_noncore(block_dict, length_dict)
noncore_pos = place_noncore(out_blocks)
core_array, core_size = place_core(block_dict)
draw_blocks(core_array, noncore_pos, core_size, args.out, args.output_format, args.genome_height, args.gap, legend_size, args.working_directory, args.ppi, args.categorise != None, args.svg_pan_zoom_location, args.hue_start, args.hue_end, add_labels=labels)

if not args.keep:
   if args.output_format in ['png', 'pdf']:
       try:
           os.remove(args.working_directory + '/temp.svg')
       except:
           pass
   try:
        os.remove(args.working_directory + '/input.fasta')
        os.remove(args.working_directory + '/circos/circos.conf')
        os.remove(args.working_directory + '/circos/circos.highlight.txt')
        os.remove(args.working_directory + '/circos/circos.image.conf')
        os.remove(args.working_directory + '/circos/circos.segdup.txt')
        os.remove(args.working_directory + '/circos/circos.sequences.txt')
        os.remove(args.working_directory + '/blocks_coords.txt')
        os.remove(args.working_directory + '/coverage_report.txt')
        os.remove(args.working_directory + '/genomes_permutations.txt')
        os.remove(args.working_directory + '/d3_blocks_diagram.html')
        os.rmdir(args.working_directory + '/circos')
        os.rmdir(args.working_directory)
   except:
       sys.stderr.write("Something went wrong when we tried to clean up the working directory. (Chromatiblock image should be fine)\n")


